Books and Learning Resources:
	Good starting point:
		The Cucumber for Java - by Aslak Hellesoy; Matt Wynne; Seb Rose
	Great tutorial for Eclipse/Maven setup, covers many areas of Cucumber
		http://www.thetestroom.com/category/web-automation/cucumber/

Installing Cucumber
	Install manually 
		download jars from Maven repository https://mvnrepository.com/
		cucumber-core - the core. Always needed if not installed from Maven
		cucumber-java - The choice of Backend module specifies which language you are going to write your glue (step definitions and hooks) in. 
		gherking - Gherkin is the name of the dialect that we use to write our feature files.  It includes the keywords, and their translations into other languages.
		cucumber-jvm-deps - dependencies
	Install with Maven
		1. Install Cucumber plugin
			Eclipse -> Help -> Install New Software -> Add
				Name: cucumber
				Location:  http://cucumber.github.com/cucumber-eclipse/update-site
		2. Create new Maven project
		3. Add Dependencies from https://mvnrepository.com/artifact/info.cukes
			cucumber-core
			cucumber-jvm-deps
			cucumber-java
			gherkin
		4. Write a .feature file
		5. Write a StepDefinition
		Source
			http://www.thetestroom.com/cucumber-maven-eclipse-setup-tutorial/
		Sampleproject
			https://github.com/asszem/CucumberLearning
	Directory Structure
		Cucumber needs you to specify where your features and step definition are kept.

General Concepts
		What makes Cucumber stand out from the crowd of other tools is that it has been designed specifically to ensure the acceptance tests can easily be read—and written—by anyone on the team. 
		This reveals the true value of acceptance tests as a communication and collaboration tool.
		Acceptance tests written in this style (Feature-Scenario-Given-When-Then-And) become more than just tests; they become executable specifications.
		Gherkin -> Step Definitions (Java) -> test specific code
	Runnin Cucumber
		When you run Cucumber
		1. it reads in your specifications from plain-language text files called features
		2. examines them for scenarios to test
		3. runs the scenarios against your system. 
		Each scenario is a list of steps for Cucumber to work through. 
		So that Cucumber can understand these feature files, they must follow some basic syntax rules. The name for this set of rules is Gherkin.
	Scenario
		Each test case in Cucumber is called a scenario, and scenarios are grouped into features. Each scenario contains several steps.
	Feature files
		The business-facing parts of a Cucumber test suite, stored in feature files, must be written according to syntax rules—known as Gherkin—so that Cucumber can read them.
		The keywords Feature, Scenario, Given, When, and Then are the structure, and everything else is documentation. This structure is called Gherkin
	Step Definitions
		Map the business-readable language of each step into code to carry out whatever action is being described by the step.
		If the code in the step definition executes without error, Cucumber proceeds to the next step in the scenario. 
		If it gets to the end of the scenario without any of the steps raising an error, it marks the scenario as having passed. 
		If any of the steps in the scenario fail, however, Cucumber marks the scenario as having failed and moves on to the next one.
		As the scenarios run, Cucumber prints out the results showing you exactly what is working and what isn’t.
		As soon as it encounters a failed or pending step, Cucumber will stop running the scenario and skip the remaining steps.
		Remember that a step isn’t a test in itself. The test is the whole scenario, and that isn’t going to pass until all of its steps do.

Gherkin Summary
	Sample
		Feature: Name of the feature
			Description of the 
			feature
			which can be
			multiple lines
			In order to <meet some goal>
			As a <type of stakeholder>
			I want <a feature>
		Background: //Same for all scenarios
			Description of background tasks
			Given ......
			And .....
		Scenario: .......
			When .....
			And .....
			And .....
			Then .....
			And .....
	Keywords
		Feature
			The feature keyword doesnt affect the behaviour of the Cucumber tests at all. Can be as long as many and can be multiple lines
			The text immediately following on the same line as the Feature keyword is the name of the feature, and the remaining lines are its description. 
			A Feature MUST be followed either by: Scenario / Bakcground / Scenario Outline
		Scenario
			Each feature can contain several scenarios. Each scenario is a single, concrete example of how the system should behave in a particular situation
			All scenarios together should describe the expected bahavior of the feature itself. Features usually have 5-20 scenarios
			Scenarios are used to explore edge cases and different paths through a feature
			A Scenarion name and Description can be multiple lines, up until the first Given/When/Then keywords
			Scenario naming is important
				When the test breaks, failing scenario name will be displayed
				Think of it as naming methods
				If the scenario is named well, the steps inside of it doesn't need to be read to understand what the scenario does. 
				A good tip is to avoid putting anything about the outcome (the Then part) of the scenario into the name and concentrate on summarizing the context and event (Given and When) of the scenario.
		Given, When, Then
			Given - it is the context
			When  - it is the event, or action in the defined context
			Then  - it is the expected outcome
		And, But
			Each Given / When / Then can be extended with And or But steps.
			Actually, And and But can be replaced with Given
			Example
				Given I have $100 in my account
				But my card is invalid
				When I request $50
				Then my card shoudl not be returned
				And I should be told to contact the bank
			Same example:
				Given I have $100 in my account
				Given my card is invalid
				When I request $50
				Then my card shoudl not be returned
				Then I should be told to contact the bank
		* to replace Given/When/Then
			Same example
				* I have $100 in my account
				* my card is invalid
				* I request $50
				* my card shoudl not be returned
				* I should be told to contact the bank
		# for Comments
	Stateless
		Each scenario must make sense and be able to be executed independently of any other scenario!!!
		When writing a scenario, always assume that it will run against the system in a default, blank state. Tell the story from the beginning, using Given steps to set up all the state you need for that particular scenario.

Step Definitions
	General description
		Step definitions sit right on the boundary between the business’s domain and the programmer’s domain.
		Gherkin describes WHAT to do, Step Definition describes HOW to do it
		There are two sides to a step definition. On the outside, it translates from plain language into code, and on the inside it tells your system what to do using automation code. 
		Step vs. Step Definition
			Step
				A Step is just documentation in plain language. It needs a Step Definition to bring it to life. 
			Step Definition
				The code to run when Cucumber matches a Step in the Feature file
		Step Matching
			Regexp Capture Groups (capturegroup)
				When you surround part of a regular expression with PARENTHESES, it becomes a capture group.
				Capture groups are used to highlight particular parts of a pattern that you want to lift out of the matching text and use. 
				In a Cucumber step definition, the text matched within each capture group is passed to the code block as an argument:
				Example
											  (      )      (    )
					@Given("^the price of a \"([^\"]*)\" is (\\d+)c$")
					public void thePriceOfAIsC(String name, int price) throws Throwable {}
			Typical regex matches
				\\d - match any numbers
				\\w - match any word character [A-Za-z0-9_]
				\\s - match any whitespace characters [\t\r\n]. Space, Tab, LineBreak
				\\b - word boundary
			Quantifiers
				* - zero or many
				+ - on or many
				? - optional, zero or many. Useful to handle plural(s)
				| - or. Example: "When I visit|go the homepage..."
			Non-Capturing groups: (?:....)
				Regex matches it but doesn't add to the capturing group

Scenario execution
	1. Read first step
	2. Is there matching step definition?
		No: UNDEFINDED SCENARIO
	3. Execute ste definition's code
	4. Was an exception thrown?
		Yes:
			Is it a Pending Exception?
				Yes: PENDING SCENARIO
				No: FAILED SCENARIO
	5. Are there any more test steps?
		Yes: Goto Step 1.
		No: PASSED SCENARIO

Background Best Practices
	A background section in a feature file allows you to specify a set of steps that are common to every scenario in the file. 
	Backgrounds are useful for taking Given (and sometimes When) steps that are repeated in each scenario and moving them to a single place. This helps keep your scenarios clear and concise.
	You can have a single Background element per feature file, and it must appear before any of the Scenario or Scenario Outline elements. 
	Just like all the other Gherkin elements, you can give it a name, and you have space to put a multiline description before the first step. 
	Tips
		Don’t use Background to set up complicated state unless that state is something the reader actually needs to know. 
			For example, we didn’t mention the actual digits of the system-generated PIN in the previous example, because that detail wasn’t relevant to any of the scenarios.
		Keep your Background section short. After all, you’re expecting the user to actually remember this stuff when reading your scenarios. 
			If the background is more than four lines long, can you find a way to express that action in just one or two steps?
		Make your Background section vivid. Use colorful names and try to tell a story, because your readers can keep track of stories much better than they can keep track of dull names like User A, User B, Site 1, and so on. 
			If it’s worth mentioning at all, make it really stand out.
		Keep your scenarios short, and don’t have too many. If the Background is more than three or four steps long, think about using higher-level steps or splitting the feature file in two.
			You can use a background as a good indicator of when a feature is getting too long: if the new scenarios you want to add don’t fit with the existing background, consider splitting the feature.
		Avoid putting technical details such as clearing queues, starting back-end services, or opening browsers in a background. 
			Most of these things will be assumed by the reader, and there are ways to push those actions down into your support code that we’ll explain later in the book, such as in Tagged Hooks.

Data Tables
	The table starts on the line immediately following the step, and its cells are separated using the pipe character: |. 
	You can line up the pipes using whitespace to make the table look tidy, although Cucumber doesn’t mind whether you do; it will strip out the values in each cell, ignoring the surrounding whitespace.
	Example
		Given these Customers:
		| country 	| ID   		|
		| 897		| 89960B	|
		| 760		| 543678	|
		Then I can also specify headings in the first row:
		| country 	| 897		|
		| ID		| 89960B	|
		And I can specify just a list:
		|item 1|
		|item 2|
		|item 3|
		|item 4|
	StepDefinition for handling tables:
		DataTable object will be retrieved from Feature file. 
			.raw() method gets each line
			DataTable is unmodifiable, so it's content needs to be changed to an ArrayList
			ArrayList can be manipulated with .get(index) and .set(index, value) methods
		Example
			@Given("^customers are:$")
			public void customers_are(DataTable inputTable) throws Throwable {
				ArrayList modifiableList = new ArrayList<List<String>>(); 					// Create an array list that will hold List<String>
				for (List<String> currentRow : inputTable.raw()) { 							// Retrieve each row from table as List<String>
					modifiableList.add(new ArrayList<String>(currentRow)); 					// Add the current row to the ArrayList
				}

Scenario Outline
	Description
		We indicate placeholders within the scenario outline using angle brackets (<..>) where we want real values to be substituted. 
		The scenario outline itself is useless without an Examples table, which lists rows of values to be substituted for each placeholder.
		You can have any number of Scenario Outline elements in a feature and any number of Examples tables under each scenario outline. 
		Behind the scenes, Cucumber converts each row in the Examples table into a scenario before executing it.
	Multiple Examples can be used
		Scenario Outline: Withdraw fixed amount
		  Given I have <Balance> in my account
		  When I choose to withdraw the fixed amount of <Withdrawal>
		  Then I should <Outcome>
		  And the balance of my account should be <Remaining>
		  
		  Examples: Successful withdrawal
			| Balance | Withdrawal | Outcome              | Remaining |
			| $500    | $50        | receive $50 cash     | $450      |
			| $500    | $100       | receive $100 cash    | $400      |

		  Examples: Attempt to withdraw too much
			| Balance | Withdrawal | Outcome              | Remaining |
			| $100    | $200       | see an error message | $100      |
			| $0      | $50        | see an error message | $0        |
	Scenario Outlines vs Data Tables
		Remember that although the syntax for writing them in Gherkin is the same, these tables are totally different from the data tables we described earlier in this chapter.
		Data tables just describe a lump of data to attach to a single step of a single scenario
	Best Practices
		Do not use to many exmaples, might slow down the system and make it hard to read
		The ultimate goal is readability, not making sure everything is tested
		The absence of proof (no proof that system is bugfree) is not the proof of absence (system is NOT bugfree)

CommandLine 
	.P- 
		. step is passed
		P step is pending
		- step has been skipped
	Tell Cucumber to use camelCase when running from a command line
		java -cp "jars/*" cucumber.api.cli.Main -p pretty --snippets camelcase features
	Tell Cucumber to use shorter output
		java -cp "jars/*" cucumber.api.cli.Main -p progress --snippets camelcase features
	Run a dry run - to check whether Gherkin is valid
		java -cp "jars/*;." cucumber.api.cli.Main -g step_definitions --dry-run features
	
