****************GITTING STARTED*****************
Create a new local repository & setting an upstream tracking branch
	git init
	git remote add origin URL
		[make one commit so HEAD will point to master]
	git push -u origin master

****************COMMANDS***********************
git status
	git st
		alias for git status
	git st -s
		show short status. Left column: Index, right column:WD
		Example: 
		MM - modified file in Index and WD
		 M - modified file in WD
		?? - untracked file

git branch
	tutorial on branch:
		https://git-scm.com/book/en/v2/Git-Branching-Basic-Branching-and-Merging
		https://git-scm.com/book/en/v2/Git-Branching-Remote-Branches
	List Branches
		git branch
	See latest commits on each branch
		git branch -v
	See all branches that are merged/not merged to the CURRENT branch
		git branch --merged
		git branch --no-merged
	Create new branch
		git branch newbranchname
	Delete a branch
		git branch -d branchname
	Delete a branch even if there are unmerged files on that branch (DANGEROUS! Unmerged files will be lost)
		git branch -D branchname
	Push to a remote branch
		git push remotename/branchname
	Set a remote branch to track an already existing local branch
		git checkout localbranch
		git branch -u remotename/remotebranchname

git checkout
	description
		git checkout newbranchname - switches to newbranchname
		git checkout -b newbranchname - creates and switches to newbranchname (same as "git branch newbranchname")
		Moves the HEAD to the branch
		When you switch branches in Git, files in your working directory will change. 
		If you switch to an older branch, your working directory will be reverted to look like it did the last time you committed on that branch. 
		If Git cannot do it cleanly, it will not let you switch at all.
	Scenarios (Repo-Staging-WorkingDir)
		- unstaged files will not be deleted when changing branches
		- staged files will not be deleted when changing branches
	
git log
	To display the number of deletions/additions in commits
		git log --stat
	To display the patch (diff) of commits
		git log -p
	To find commits in specific files
		git log -- filename
	To find new commits between branch1 and branch 2. The range contains all of the commits that are in branch2, but aren’t in branch1. Changing order will give different result
		git log branch1..branch2
	To find commits containing a specific string
		git log -S"string to find"
		git log -G<regexp>
	To find commit differences between two commits (2 dots)
		git log commit1..commit2
		Example
			A - B - E - F --Commit1
			      \	C - D --Commit2
			git log commit1..commit2
				shows the commits that are included in commit2 but not in commit 1: CD
			git log commit2..commit1
				shows the commits that are included in commit1 but not in commit2: EF
	To find all commits that are not common between two commits (3 dots)
		git log commit1...commit2
		git log --left-right commit1-commit2
			to show which commit belongs to which
	See GitBestPractices for git log formats set to aliases
	Source:
		https://www.atlassian.com/git/tutorials/git-log
		https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection

git diff 
	Explanation of a sample diff:
		diff --git a/git notes/GitKnowledge.txt b/git notes/GitKnowledge.txt
			displays the input of diff
		index 5047418..24a5e72 100644
			The SHA checksum of old/new files. These are NOT commit checksums
		--- a/git notes/GitKnowledge.txt
		+++ b/git notes/GitKnowledge.txt
			--- is for file a (can be considered the OLD version)
			+++ is for file b (can be considered the NEW version)
		@@ -88,7 +88,7 @@ git reflog
			@@ marks a (c)hunk, that is a part that changed. Also some lines displayed before/after the change to provide context
			88,7 marks 7 lines from line 88 in file a (-)
			-- marks file a (OLD)
			++ marks file b (NEW)
		If there is only + in a hunk, it means that part is only part in the second file -> an addition in the second file
		If there is only - in a hunk, it means that it is not part of the second file ->a deletion in the second file
	Examples:
		git diff
			Shows the changes in the unstaged (but tracked) files
		git diff --cached or git diff --staged
			Shows the changes in the staged files
		git diff HEAD
			Shows all diffs of current head
		git diff HEAD~3
			Shos the diff of Head 3 steps before
		git diff file
			Shows the diff of a specific unstaged file
		git diff --cached file 
			Shows the diff of a staged specific file
	Sources
		Excellent description on how to read diff output. Recommended to start with
			https://www.git-tower.com/learn/git/ebook/en/command-line/advanced-topics/diffs#start
		Comprehensive Guide to understand how diff works. Not easy.
			http://www.gnu.org/software/diffutils/manual/html_node/index.html#SEC_Contents

git reset
	format
		git reset [--mixed] target
			The staged snapshot is updated to match the specified commit, but the working directory is not affected. This is the default option.
		git reset --soft target
			The staged snapshot and working directory are not altered in any way.
		git reset --hard target
			The staged snapshot and the working directory are both updated to match the specified commit.
	examples:
		git reset --soft HEAD~
			Undo last commit (move Head back 1), dont change Index and Working Directory
			When you reset back to HEAD~ (the parent of HEAD), you are moving the branch back to where it was, without changing the Index or Working Directory.
		git reset  [--mixed] HEAD~
			Undo last commit, unstage Index (everything).
			You rolled back to before you ran all your git add and git commit commands.
			The next thing reset will do is to update the Index with the contents of whatever snapshot HEAD now points to.
		git reset --hard HEAD~
			Undo last commit, Update Index and Working directory with the contents of whatever HEAD now points to
			Note: to restore WD content after a hard reset, use git reflog
	tutorials on reset
		https://git-scm.com/book/en/v2/Git-Tools-Reset-Demystified
		Source: https://www.atlassian.com/git/tutorials/resetting-checking-out-and-reverting
	reset vs checkout	
		Reset will move the branch that HEAD points to
		Checkout will move HEAD itself to point to another branch.

git rebase
	tutorials on rebase
		https://git-scm.com/book/en/v2/Git-Branching-Rebasing
	description
		reapplies a series of commits to a new parent commit then moves the current branch pointer
		the log of a rebased branch looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel.

git merge
	tips & tricks
		create a test_merge branch before merging
			http://think-like-a-git.net/sections/testing-out-merges/the-scout-pattern.html
		create a savepoint branch before merging 
			(but don't change to it, and git reset --hard savepoint if something goes wron)
			http://think-like-a-git.net/sections/testing-out-merges/the-savepoint-pattern.html

git reflog
	Show all SHA checksums of every commit
	Reflog is a mechanism to record when the tip of branches are updated. This command is to manage the information recorded in it.
	http://gitready.com/intermediate/2009/02/09/reflog-your-safety-net.html

git clean
	Cleans the workspace, remove untracked files (can not be recovered!)
	-i interactive
	-n dry run
	-f force 
	
git alias 
	git alias
		Set an alias to list all aliases:
		git config --global alias.alias "config --get-regexp ^alias\."
		source:http://stackoverflow.com/questions/7066325/list-git-aliases

git stash
	Description
		Stashing takes the dirty state of your working directory – that is, your modified tracked files and staged changes – and saves it on a stack of unfinished changes that you can reapply at any time.
	git stash list
		List all stashes
	git stash
		stashes modified and staged changes of current branch
	git stash -u --include-untracked
		stashes untracked files as well
	git stash --patch
		opens an interactive session to stash only specific stashes of files
	git stash apply
		restores from last stash, but keep it in the stash. Everything is restored to WD, even those files that were Staged
	git stash apply --index
		restores from stash, keeping files indexed that were staged when the stash was created
	git stash pop
		restores from last stash, removes it from stash list
	git stash branch newbranchname
		creates a new branch and reapplies the stash content ot that branch

	Sources
		https://git-scm.com/book/en/v2/Git-Tools-Stashing-and-Cleaning	

git filter-branch - NOT 100% SURE YET!
	Warning - use it only on not published commits as it rewrites history!
	Description
	It can be used to rewrite large number of commits ina sciptable way, for example changing email address or remove some files in every commit
	/refs/original/* is as a bakcup after filter-branch
		To remove it:
		git update-ref -d refs/original/refs/heads/master
	Examples
		Remove a file "passwords.txt" from every commits (in the branch)
			git filter-branch --tree-filter 'rm -f passwords.txt'
				--tree-filter runs the command after each checkout of the project and then recommits the results. 
				Tipp: do this in a testing branch, check result and hard-reset to master branch.
			git filter-branch --tree-filter --all 'rm -f passwords.txt'
				--all runs the command on ALL branches
	Source
	https://git-scm.com/book/en/v2/Git-Tools-Rewriting-History
	Info on what is refs/original/heads/master
		http://stackoverflow.com/questions/7654822/remove-refs-original-heads-master-from-git-repo-after-filter-branch-tree-filte
	General info on filter branch
	http://git-memo.readthedocs.io/en/latest/filter-branch.html


*****************Visual Tools*********************** 
	gitk
		read-only visual representation of the repository / commits / branches
		To visualize All Branch History:
			gitk -all

	git gui
		visual tool to review changes, sign-off commits and perform many tasks, like merge, commit, reset, etc

****************KEYWORDS***********************
HEAD
	HEAD is the pointer to the current branch reference, which is in turn a pointer to the last commit made on that branch. That means HEAD will be the parent of the next commit that is created. It’s generally simplest to think of HEAD as the snapshot of your last commit.
	Ancestry references
		^  - If you place a ^ at the end of a reference, Git resolves it to mean the parent of that commit. 
		^2 - The 2nd parent, if a commit had more parents (a merge commit for example, ^1 is the merged to branch, ^2 is the merged from branch)
		~  - the parent of the reference
		~n - the nth parent of a reference (grandparents)
	Examples:
		HEAD~   - The PARENT of HEAD (1 step before)
		HEAD~3  - The 3rd parent of HEAD (parent of parent of parent)
		HEAD^	-  The parent of head
		HEAD^^  - The 2nd parent of HEAD

	Detached HEAD
		HEAD refers to a specific commit, as opposed to referring to a named branch.
	Source
		https://git-scm.com/book/en/v2/Git-Tools-Revision-Selection

CONFLICT
	When the exact same line was modified in two different ways - git can't determine which version to keep

********************Netbeans Versioning Considerations********************
	The build (or nbbuild), dist (or nbdist), and the nbproject/private folders should not be checked into that version control system.
	Though nbproject/private should be ignored, nbproject should be checked into the version control system.
	Nbproject contains project metadata that enables others users to open the project in NetBeans without having to import the project first.

	source
		http://docs.oracle.com/cd/E50453_01/doc.80/e50452/create_japps.htm#NBDAG2974

********************SOURCES********************
	https://www.kernel.org/pub/software/scm/git/docs/user-manual.html
		Comprehensive Documentation of Git

	https://git-scm.com/book/en/v2
		Comprehensive Guide for Git

	http://ndpsoftware.com/git-cheatsheet.html	
		Excellent visual representation of Stash/Workspace/Index/Local repository/Upstream repository and how commands move content between stages

	http://marklodato.github.io/visual-git-guide/index-en.html#basic-usage
		This page gives brief, visual reference for the most common commands in git. Once you know a bit about how git works, this site may solidify your understanding

	http://onlywei.github.io/explain-git-with-d3/#commit
		Visual and animated tool to understand concepts

	Small GIT cards to memorize stuff
		http://tednaleid.github.io/understanding-git/
		
